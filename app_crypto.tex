\section{Further Background and Discussion on the Cryptographic Primitives Used}
\label{app:crypto}
\TODO{add + subsection of appendix}
\subsection{Brief Introduction to Computationally Sound Proof Systems}
\paragraph{Computationally Sound Proofs}
The idea of a proof system that its soundness only holds for adversaries of bounded computational power (also known as an argument) was introduced by Micali in \cite{micali2000computationally}, and was based on an earlier interactive protocol of Kilian (\cite{kilian1992note}) and a variant of the Fiat-Shamir paradigm~\cite{fiat1986prove}.
Kilian's protocol is based on the following idea. The verifier choose a key to a hash function from a collision-resistant hash family, and send it to the prover. The prover then uses a Merkle Tree \cite{merkle1989certified} induced by the hash function to commit to a polynomial Probabilistically Checkable Proof (PCP) \cite{babai1991checking, arora1998probabilistic, arora1998proof, feige1991approximating}, using the instance and the witness (that the prover has, and the verifier does not have), and send the commitment to the verifier. Next, the verifier chooses the queries for the PCP, and the prover then sends answers to the queries along with an opening of the Merkle tree, proving that these indeed where the values in the queries' indices in the PCP.
\TODO{Rotem: capitalized/uncapitalized ro and crs models?}
\paragraph{The Random Oracle Model}
A Random Oracle is simply a deterministic function that is chosen randomly from all possible functions (from a certain input length to a certain output length), that provide an oracle access: the parties cannot hold a full description of the function, but they can query it and get answers to their queries, in $O(1)$ steps per quary. Though this is not a realistic model, it is very useful in both theory and practice~\cite{ROM93BMR}. In the random oracle model, Micali used the paradigm of Fiat and Shamir~\cite{fiat1986prove}, to lose the interaction in Kilian's protocol, and by that, to obtain a computationally sound proof (which later has been called a SNARG).

\paragraph{SNARGs in the CRS model}
Since Micali's seminal work, there have been several attempts~\cite{aiello2000fast, dwork2004succinct, di2008succinct, groth2010short, bitansky2012extractable} to obtain succinct non-interactive arguments (SNARGs) in a more realistic model, but still different from the plain model: the common reference string (CRS) model.\footnote{
Some works, such as \cite{bitansky2013recursive} did construct SNARGs (in fact, SNARKs) in the plain model.
} In the CRS model, it is assumed that all parties have access to a string generated in a trusted manner. The Common Reference String model is a generalization of the Common \emph{Random} String model, where the reference string is taken from the uniform distribution (in the common \emph{reference} string model, it may be taken from any arbitrary distribution). These two versions are in fact equal in power~\cite{canetti2001universally}. The main difference between the ROM and CRS model is that proofs in the ROM are \emph{heuristic}, since the actual protocol instantiation uses a hash function that is blatantly NOT a random oracle. In contrast, proofs in the CRS model have a standard reduction-based proof of security, and so are not heuristic. The main advantage of the CRS model over the Random Oracle model is that security is standard, and doesn't rely on a heuristic belief system that the real protocol that uses a standard hash function is secure. The main disadvantage is that the CRS needs to be generated somehow, and in the absence of a trusted setup, this is not trivial. An example where CRS is used in reality is the Zcash protocol: there, the CRS is generated by a Multi-Party Computation (MPC) protocol \cite{crsZkSnark}. Whenever at least  one participant is honest, then the setup is trust-worthy.

\paragraph{SNARGs from knowledge assumptions and SNARKs}
To this day (to our knowledge), in every construction of a SNARG in the CRS (or in the plain) model, in order to prove its soundness, some knowledge assumption (or: knowledge \emph{extractability}) was assumed. Knowledge assumptions capture the intuition that any algorithm whose output is related to a certain value that is hard to compute (for instance, a convincing proof, that is related to an $\NP$-witness), must obtain that value along the computation. This assumption is non-falsifiable, meaning, one cannot define a game where at the end of the game, we could efficiently decide whether the assumption was broken or not. This is unlike hardness assumptions, where the design of such a game is very easy to design \TODO{word}. Under such assumptions, the SNARG candidate becomes stronger: it becomes a SNARG of knowledge --- a SNARK; instead of only being sound, we can promise (under the knowledge assumption), that any prover that manages to convince the verifier, knows a witness. This is useful for composing such arguments with other primitives, and in particular, this is useful for our constructions.

In \cite{gentry2011separating}, a substantial barrier to proving the soundness of a SNARG for $\NP$ under falsifiable assumptions was presented; it was shown that SNARGs\footnote{
The result of \cite{gentry2011separating} is specific for \emph{adaptive} soundness.
} cannot be proven secure by a reduction to \emph{any} falsifiable assumption if the reduction is black-box in the adversary's code. Since, many works were either focused on what can be done without knowledge assumptions, which include,
for example, SNARGs for deterministic computation~\cite{kalai2019delegate, jawale2021snargs, choudhuri2021snargs},
batch arguments for $\NP$~\cite{choudhuri2021non, hulett2022snargs, devadas2022rate, cryptoeprint:2022/1320},
and incrementally verifiable computation~\cite{paneth2022incrementally},
or focused on refining the knowledge assumptions used and generalizing them~\cite{bitansky2012extractable}.


\subsection{Vector Commitments, Merkle Trees, and Collision Resistant Hash Families}
\paragraph{Vector Commitments}
Vector Commitments are defined formally in~\cite{catalano2013vector}, where they are constructed in a way that makes them more succinct than what we required in this work: they show VCs \TODO{initials for VCs, SNARGs, etc} with commitment and opening length that depends only on the security parameter, and is completely \emph{independent} of the input size.

For our use, a more classic form of VCs suffices; a Merkle Tree~\cite{merkle1989certified} induced by a CRH satisfies our completeness, position-binding \TODO{capitalize?}, and succinctness requirements.
\TODO{Change hash definition to family?}
\begin{definition} [Collision-Resistant Hash (CRH)]
    A hash family $(\Gen, \Hash)$ is considered \emph{collision-resistant}, if for any efficient adversary $\mathcal{A}$, there exists a negligible function $\epsilon(\cdot)$, such that for every $\secpar\in \mathbb{N}$,
    \begin{gather*}
        \prob{}
        {
        \begin{array}{ll}
        h(x_1)=h(x_2)
        \end{array}
        \middle\vert
        \begin{array}{ll}
             hk \leftarrow Gen(1^n, 1^\secpar) \\
             x_1, x_2 \leftarrow\calA(hk)
        \end{array}
        } \leq \epsilon(\secpar)
    \end{gather*}
\end{definition}

\paragraph{Merkle Trees} We describe Merkle Trees informally. Let $h:\{0,1\}^2k\to\{0,1\}^k$ be a function. The root of the Merkle Tree induced by $h$ on an input $x = \in\{0,1\}^{n\times 2k}$, $rt_h(x)$ is computed in $\log k$ iterations as follows. In every iteration, the current sequence (starting when the current sequence is the input) is divided into $k$-bit blocks, and $h$ is evaluated on every pair of adjacent odd and even indexed blocks, to obtain the new sequence, which its length is half the length of the previous sequence. In the end, we get a value of length $O(k \log n)$. This is the commitment to $x$. To open a commitment in position $i$, which is the $i$th $2k$-bit block of $x$, the committer only has to show one node in every level of the commitment tree (except for the lowest level, where it has to show two nodes). A verifier can verify that in each level, $h$ was evaluated correctly.

If $h$ is taken from a CRH family, then this scheme is a position-binding VC, since in order to open the same position in two different ways, one must find a collision.

Moreover, for our use in Section~\ref{sec:dargsForP} \TODO{verify all labels and references and capitalized Sections}, where we also require the VC be \emph{inverse collision-resistant}, it is essential we use Merkle Trees. This is because Merkle Trees are based on a \emph{deterministic} function, and the process of verifying an opening is based on evaluating the same function that is used for the commitment. In order to obtain two different commitments and full openings of them (that is, opening for every position to each commitment), one needs to find two different \emph{outputs} for the same \emph{input} of a deterministic function, which is impossible. Note that in the definition of the inverse collision-resistance property, we allowed this to happen with a negligible probability, because nothing more is necessary for our proof, but in fact, when instantiating the VC by a Merkle Tree, we can promise that such "inverse collisions" are never found.

\subsection{SNARKs for $\NP$}
There is an abundance of constructions of SNARKs. In this work, we refer to the construction in \cite{bitansky2013SNARKsLIPs}, but it could be replaced by any \emph{publically verifiable} SNARK construction, with or without preprocessing. We refer to~\cite{bitansky2013SNARKsLIPs, bitansky2013recursive} for more details on public vs. private verifiability and preprocessing in SNARKs.
From the construction in \cite{bitansky2013SNARKsLIPs}, we get SNARKs for $\NP$ from the knowledge-of-exponent assumption in bilinear groups. 
\TODO{Copy it?}

\subsection{RAM SNARGs for Deterministic Computation}\label{app:ramsnargs}
For a polynomial-time Turing machine $M$, we would like to have a way of verifying that the execution of $M$ on input $x$ was executed correctly, and in particular, the output is correct. We would like to do that more efficiently than simulating the computation, and more importantly, without having access to the entire input. RAM Delegation allows us to do so. In general, a RAM Machine is a deterministic Turing machine that has random access to memory that is much longer (mostly, exponentially longer) than its local state, and a RAM SNARG is a SNARG that proves that a RAM machine indeed outputs a certain output, without having the verifier simulate the entire execution (that requires access to a long memory). A RAM SNARG is associated with a \emph{digest} algorithm, that processes the long input into a much shorter string that the verifier can read. In \cite{cryptoeprint:2022/1320}, this definition is extended to \emph{Flexible SNARGs for RAM}, which is a RAM SNARG where the digest can be implemented by any hash family, and the SNARG is sound if that hash family has local openings.

Let $M$ be a RAM machine. A flexible RAM SNARG for $M$ is associated with a hash family with local opening\footnote{
For the use in \cite{cryptoeprint:2022/1320}, and for our use, a succinct vector commitment satisfies all the required properties of the hash with local openings, where $\HTGen = \VCGen, \HTHash = \VCCom, \HTOpen = \VCOpen, \HTVer = \VCVer$
}
$$\HT = \HTGen, \HTHash, \HTOpen, \HTVer$$ and consists of the following  algorithms.\footnote{
In \cite{cryptoeprint:2022/1320}, they include in the SNARG definition also the digestion algorithm, that uses a key generated by $\Gen$ and applies $\HTHash(x)$ to obtain $d$. Since this is fully defined by the rest of the algorithms mentioned here, we omit it from the definition.
}
\paragraph{$\Gen(1^\secpar, T)\to \var{\crs%, hk, vk
}$:} a setup procedure that takes as input a security parameter $1^\secpar$ and a time bound $T$, and outputs a common reference string $\var{\crs}$.

\paragraph{$\Pro(\var{\crs}, x)\to b, \pi$:}\footnote{
In \cite{cryptoeprint:2022/1320}, the input $x$ is divided into a short explicit input $x_{exp}$ that the verifier has, and a long input the verifier doesn't have $x_{imp}$. Since it is not required for the SNARG's properties that $x_{exp}$ be non-empty, and we only use the node's input outside the SNARG itself, we omit $x_{exp}$ from the definition.
}
takes a common reference string $\var{\crs}$ obtained from $\Gen(1^{\secpar}, T)$,
an instance $x\in\{0,1\}^\ell$, and outputs a bit $b = M(x)$ and a proof $\pi$.

\paragraph{$\Ver(\var{\crs}, %vk,
d, b, \pi)\to \set{0,1}$:} takes a common reference string $\var{\crs}$, %a verification key for $\HT$, $vk$,
a digest if memory $d$, an output bit $b$, and proof $\pi$,
and outputs an acceptance bit.


\begin{definition}[Flexible RAM SNARGs]
\Enote{I might have over-copied here}
Let $M$ be a RAM machine. A Flexible RAM SNARG for $M$ associated with a hash family with local opening
$\HT = (\HTGen, \HTHash, \HTOpen, \HTVer)$ satisfies the following properties.
\paragraph{Completeness} 
There exists a negligible function $\epsilon(\cdot)$, such that for every $\lambda, n\in \mathbb{N}$ such that $n\leq T(n) \leq 2^\lambda$, and every $x\in \{0,1\}^n$ such that $M$ on $x$ halts after $T(n)$ steps,
\begin{gather*}
    \prob{}
    {
    \begin{array}{ll}
    \Ver(\crs, d, b, \pi) = 1 \\
    \wedge b = M(x)
    \end{array}
    \middle\vert
    \begin{array}{ll}
    \var{\crs} \leftarrow \Gen(1^\secpar, T) \\
    (b, \pi) \leftarrow \Pro(\crs, x) \\
    d \leftarrow \HTHash(crs, x)
    \end{array}
    } = 1 - \epsilon(\lambda)
\end{gather*}

\paragraph{Soundness}\footnote{
In \cite{cryptoeprint:2022/1320}, it is shown that this soundness notion can be replaced by a different one, called \emph{Partial Input Soundness}. We do not require it.
}
For any efficient adversarial prover $\Pro^*$ and a polynomial $T = T(\lambda)$, there exists a negligible function $\epsilon(\cdot)$, such that
\begin{gather*}
    \prob{}
    {
    \begin{array}{ll}
    \Ver(\var{\crs}, d, 0, \pi_0) = 1 \\
    \wedge \Ver(\crs, d, 1, \pi_1) = 1
    \end{array}
    \middle\vert
    \begin{array}{ll}
    \var{\crs} \leftarrow \Gen(1^\secpar, T) \\
    (d, x, \pi_0, \pi_1) \leftarrow \Pro^*(\var{\crs}) \\
    \end{array}
    } \leq \epsilon(\secpar)
\end{gather*}
\paragraph{Succinctness} The length of the proof output of $\Pro$ is $\poly(\lambda, \log n,\log T)$.
\paragraph{Verifier Efficiency} $\Ver$ runs in time $\poly(\lambda, |\pi|) = \poly(\lambda, \log n, \log T)$    
\end{definition}


