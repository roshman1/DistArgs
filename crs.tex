The cryptographic primitives that we use are proved sound in the \emph{common reference string} (CRS) model,
where we assume that a trusted setup phase has occurred, during which all parties get access to
a \emph{common reference string} drawn from a known distribution.
For example, the CRS can be used to select a random hash function
from a family of hash functions.
%which is essentially shared randomness between the prover and the verifiers (which the prover is not able to influence): for example, the prover and the verifiers may need to agree on a hash function, which is chosen uniformly at random from a large family of functions. CRS is a common assumption, underlying most of the work on delegated computation.
%We believe that CRS is an appropriate assumption for our setting, %where the prover is not truly ``malicious'' but rather ``misguided'' or ``misinformed'', reflecting bugs in the code or changes in the network.
In the distributed prover of Section~\ref{sec:distprover},
the CRS can be generated by having every node $v$ propose a random string $r_v$,
and summing the strings up a spanning tree to produce $\crs = \oplus_{v \in V} r_v$,
which is then disseminated to all the nodes. As long as a single node generates its random string honestly, the resulting $\crs$
will be uniformly random.